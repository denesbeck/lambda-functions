name: Deploy Lambda

on:
  push:
    branches:
      - "**"

permissions:
  id-token: write
  contents: read

jobs:
  deploy:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        region: [us-east-1, eu-central-1]

    environment: ${{ matrix.region }}

    env:
      FUNCTIONS_S3_BUCKET: ${{ vars.FUNCTIONS_S3_BUCKET }}
      LAYERS_S3_BUCKET: ${{ vars.LAYERS_S3_BUCKET }}
      HASHES_S3_BUCKET: ${{ vars.HASHES_S3_BUCKET }}
      REGION: ${{ vars.REGION }}
      ACCOUNT_NUMBER: ${{ secrets.ACCOUNT_NUMBER }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Install jq
        run: sudo apt-get update && sudo apt-get install -y jq

      - name: Set up AWS credentials
        uses: aws-actions/configure-aws-credentials@v5
        with:
          role-to-assume: arn:aws:iam::874820004530:role/GitHubActionsDeployRole
          aws-region: ${{ vars.REGION }}

      - name: Get AWS account ID
        id: get-account
        run: |
          ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
          echo "account-id=$ACCOUNT_ID" >> "$GITHUB_OUTPUT"

      - name: Download previous hash files from S3
        run: |
          mkdir -p .hash-cache
          BRANCH="${{ github.ref_name }}"
          find functions -mindepth 2 -maxdepth 2 -type d | while read func_dir; do
            APP=$(basename "$(dirname "$func_dir")")
            FUNC=$(basename "$func_dir")
            TARGET=".hash-cache/functions/$APP/$FUNC"
            mkdir -p "$TARGET"
            aws s3 cp --region "$REGION" "s3://${HASHES_S3_BUCKET}/functions/$BRANCH/$APP-$FUNC.code.hash" "$TARGET/.code.hash" || true
            aws s3 cp --region "$REGION" "s3://${HASHES_S3_BUCKET}/functions/$BRANCH/$APP-$FUNC.config.hash" "$TARGET/.config.hash" || true
          done

      - name: Get layer directories
        id: layer_dirs
        run: |
          echo "Get layer directories..."

          DIRS=$(find . -mindepth 2 -maxdepth 2 -type d -not -path '*/.*' | cut -c 3- | sort -u | awk -F/ '$1 == "layers"')

          if [[ -z "$DIRS" ]]; then
            echo "No layer directories found. Skipping deployment."
          else
            echo "Layer directories:"
            echo "$DIRS"
            echo "dirs<<EOF" >> $GITHUB_OUTPUT
            echo "$DIRS" >> $GITHUB_OUTPUT
            echo "EOF" >> $GITHUB_OUTPUT
          fi

      - name: Package and deploy layers
        if: steps.layer_dirs.outputs.dirs != ''
        run: |
          set -euo pipefail

          TIMESTAMP=$(date +%Y%m%d%H%M%S)
          COMMIT_SHA=${{ github.sha }}
          BRANCH="${{ github.ref_name }}"

          DEPLOY_ALIAS=$(./scripts/get-alias.sh "$BRANCH")
          echo "Branch '$BRANCH' will deploy to alias: $DEPLOY_ALIAS"

          while IFS= read -r path; do
            LAYER=$(basename "$path")

            CONFIG_FILE="${path}/config.json"
            if [[ ! -f "$CONFIG_FILE" ]]; then
              echo "Missing config.json in $path, skipping..."
              continue
            fi

            LAYER_NAME=$(jq -r .name "$CONFIG_FILE")
            DESCRIPTION=$(jq -r .description "$CONFIG_FILE")
            TYPE=$(jq -r .type "$CONFIG_FILE")
            COMPATIBLE_RUNTIMES=$(jq -c .runtimes "$CONFIG_FILE")

            ZIP_FILE="${LAYER}-${TIMESTAMP}-${COMMIT_SHA}.zip"
            S3_KEY="${LAYER}/${ZIP_FILE}"

            echo "Zipping $path..."
            cd "$path"
            ../../scripts/install-packages.sh "$TYPE"

            zip -r "../../$ZIP_FILE" . > /dev/null
            cd - > /dev/null

            echo "Uploading to s3://${LAYERS_S3_BUCKET}/${S3_KEY}"
            aws s3 cp --region "$REGION" "$ZIP_FILE" "s3://${LAYERS_S3_BUCKET}/${S3_KEY}"

            echo "Publishing new layer version..."
            ACCOUNT_NUMBER=$(aws sts get-caller-identity --query Account --output text)
            VERSION=$(aws lambda publish-layer-version \
              --layer-name "arn:aws:lambda:$REGION:$ACCOUNT_NUMBER:layer:$LAYER_NAME" \
              --description "$DESCRIPTION" \
              --content S3Bucket="$LAYERS_S3_BUCKET",S3Key="$S3_KEY" \
              --compatible-runtimes "$COMPATIBLE_RUNTIMES" \
              --region "$REGION" \
              --output text \
              --query 'Version')

            echo "Published version $VERSION of $LAYER_NAME"

            echo "Cleaning up..."
            rm "$ZIP_FILE"

          done <<< "${{ steps.layer_dirs.outputs.dirs }}"

      - name: Get Lambda directories
        id: function_dirs
        run: |
          echo "Get Lambda directories..."

          DIRS=$(find . -mindepth 3 -maxdepth 3 -type d -not -path '*/.*' | cut -c 3- | sort -u | awk -F/ '$1 == "functions"')

          if [[ -z "$DIRS" ]]; then
            echo "No Lambda directories found. Skipping deployment."
          else
            echo "Lambda directories:"
            echo "$DIRS"
            echo "dirs<<EOF" >> $GITHUB_OUTPUT
            echo "$DIRS" >> $GITHUB_OUTPUT
            echo "EOF" >> $GITHUB_OUTPUT
          fi

      - name: Generate code and config hashes
        run: bash ./scripts/generate-function-hashes.sh

      - name: Zip, upload to S3, and deploy Lambda
        if: steps.function_dirs.outputs.dirs != ''
        run: |
          set -euo pipefail

          TIMESTAMP=$(date +%Y%m%d%H%M%S)
          COMMIT_SHA=${{ github.sha }}
          BRANCH="${{ github.ref_name }}"

          DEPLOY_ALIAS=$(./scripts/get-alias.sh "$BRANCH")
          echo "Branch '$BRANCH' will deploy to alias: $DEPLOY_ALIAS"

          while IFS= read -r path; do
            echo "Processing $path..."

            APP=$(echo "$path" | cut -d'/' -f2)
            LAMBDA=$(echo "$path" | cut -d'/' -f3)

            CONFIG_FILE="${path}/config.json"
            if [[ ! -f "$CONFIG_FILE" ]]; then
              echo "Missing config.json in $path, skipping..."
              continue
            fi

            FUNCTION_NAME=$(jq -r .function_name "$CONFIG_FILE")
            RUNTIME=$(jq -r .runtime "$CONFIG_FILE")
            HANDLER=$(jq -r .handler "$CONFIG_FILE")
            ROLE_NAME=$(jq -r .role "$CONFIG_FILE")
            IAM_ROLE_ARN="arn:aws:iam::${ACCOUNT_NUMBER}:role/${ROLE_NAME}"
            LAYER_STRINGS=$(jq -r '.layers[]' "$CONFIG_FILE")
            LAYER_ARNS=""
            for LAYER in $LAYER_STRINGS; do
              LAYER_NAME=$(echo "$LAYER" | cut -d':' -f1)
              LAYER_VERSION=$(echo "$LAYER" | cut -d':' -f2)
              LAYER_ARNS+="arn:aws:lambda:${REGION}:${ACCOUNT_NUMBER}:layer:${LAYER_NAME}:${LAYER_VERSION} "
            done
            LAYERS="${LAYER_ARNS%% }"

            CODE_HASH_FILE="$path/.code.hash"
            CONFIG_HASH_FILE="$path/.config.hash"            
            LAST_HASH_PATH=".hash-cache/$path/.code.hash"
            LAST_CONFIG_HASH_FILE=".hash-cache/$path/.config.hash"
            DEPLOY_CODE=false
            UPDATE_CONFIG=false

            if [[ ! -f "$LAST_HASH_PATH" ]]; then
              echo "No previous code hash — will deploy"
              DEPLOY_CODE=true
            else
              CURRENT_HASH=$(cat "$CODE_HASH_FILE")
              LAST_HASH=$(cat "$LAST_HASH_PATH")

              if [[ "$CURRENT_HASH" != "$LAST_HASH" ]]; then
                echo "Hash changed — will deploy"
                DEPLOY_CODE=true
              else
                echo "Code unchanged — skipping zip and version publish"
              fi
            fi

            if [[ ! -f "$LAST_CONFIG_HASH_FILE" ]]; then
              echo "No previous config hash — will update config"
              UPDATE_CONFIG=true
            else
              CURRENT_CONFIG_HASH=$(cat "$CONFIG_HASH_FILE")
              LAST_CONFIG_HASH=$(cat "$LAST_CONFIG_HASH_FILE")
              if [[ "$CURRENT_CONFIG_HASH" != "$LAST_CONFIG_HASH" ]]; then
                echo "Config hash changed — will update config"
                UPDATE_CONFIG=true
              else
                echo "Config unchanged — skipping config update"
              fi
            fi

            if [[ "$DEPLOY_CODE" == true ]]; then
              ZIP_FILE="${APP}-${LAMBDA}-${TIMESTAMP}-${COMMIT_SHA}.zip"
              S3_KEY="${APP}/${LAMBDA}/${ZIP_FILE}"

              echo "Zipping $path to $ZIP_FILE"
              cd "$path"
              zip -r "../../../$ZIP_FILE" . > /dev/null
              cd - > /dev/null

              echo "Uploading to s3://${FUNCTIONS_S3_BUCKET}/${S3_KEY}"
              aws s3 cp --region "$REGION" "$ZIP_FILE" "s3://${FUNCTIONS_S3_BUCKET}/${S3_KEY}"

              echo "Checking if Lambda function ${FUNCTION_NAME} exists..."
              if aws lambda get-function --function-name "$FUNCTION_NAME" --region "$REGION" >/dev/null 2>&1; then
                echo "Updating Lambda ${FUNCTION_NAME}..."
                aws lambda update-function-code \
                  --function-name "$FUNCTION_NAME" \
                  --s3-bucket "$FUNCTIONS_S3_BUCKET" \
                  --s3-key "$S3_KEY" \
                  --region "$REGION"
              else
                echo "Missing Lambda function: ${FUNCTION_NAME}, skipping..."
                continue
              fi

              # Wait for function update to finish
              aws lambda wait function-updated \
                --function-name "$FUNCTION_NAME" \
                --region "$REGION"

              echo "Publishing new version for ${FUNCTION_NAME}..."
              VERSION=$(aws lambda publish-version \
                --function-name "$FUNCTION_NAME" \
                --region "$REGION" \
                --output text \
                --query 'Version')

              echo "Published version $VERSION"

              echo "Updating or creating alias '$DEPLOY_ALIAS'..."
              aws lambda update-alias \
                --function-name "$FUNCTION_NAME" \
                --name "$DEPLOY_ALIAS" \
                --function-version "$VERSION" \
                --region "$REGION" || \
              aws lambda create-alias \
                --function-name "$FUNCTION_NAME" \
                --name "$DEPLOY_ALIAS" \
                --function-version "$VERSION" \
                --region "$REGION"

              echo "Cleaning up..."
              rm "$ZIP_FILE"
            fi
            
            if [[ "$UPDATE_CONFIG" == true ]]; then
              echo "Updating configuration for ${FUNCTION_NAME}..."
              aws lambda update-function-configuration \
                --function-name "$FUNCTION_NAME" \
                --runtime "$RUNTIME" \
                --handler "$HANDLER" \
                --role "$IAM_ROLE_ARN" \
                --layers $LAYERS \
                --region "$REGION"

              aws lambda wait function-updated \
                --function-name "$FUNCTION_NAME" \
                --region "$REGION"
            fi
          done <<< "${{ steps.function_dirs.outputs.dirs }}"

      - name: Upload updated hash files to S3
        run: |
          BRANCH="${{ github.ref_name }}"
          find functions -type f \( -name ".code.hash" -o -name ".config.hash" \) | while read file; do
            APP=$(basename "$(dirname "$(dirname "$file")")")
            FUNC=$(basename "$(dirname "$file")")
            NAME=$(basename "$file")
            aws s3 cp "$file" "s3://${HASHES_S3_BUCKET}/functions/$BRANCH/$APP-$FUNC$NAME"
          done
